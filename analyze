#!/usr/bin/env php
<?php

namespace PsalmWpTaint;

require_once "./vendor/autoload.php";

use PsalmAnalysisHandler;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use RecursiveRegexIterator;
use RegexIterator;
use stdClass;
use Tuncay\PsalmWpTaint\src\FunctionBodyGetter;
use Tuncay\PsalmWpTaint\src\PsalmAnalysisOutputHandler;
use Tuncay\PsalmWpTaint\src\PsalmOutputParser;

$noInstall = false;
$noAnalysis = false;

// Checking for current dir
if (str_contains(__DIR__, '')) {
    chdir("./");
}

// Checking for correct arguments
if ($argv[1] == "--help" || $argv[1] == "-h") {
    print_r("Usage:\n");
    print_r("analyze --plugin_list ./absolute/path/to/file/with/plugins/list. \n");
    print_r("The plugin list should be a .csv file with the first column being the plugin name slugs and the second being the plugin versions.\n");
    exit();
}

if ($argv[1] == "--no-install") {
    $noInstall = true;
}

if ($argv[2] == "--no-analysis") {
    $noAnalysis = true;
}

if ($argc != 3 && !$noInstall && !$noAnalysis) {
    print_r("Invalid number of options. Use --help or -h to show list of options.\n");
    exit();
}

// Correct number of arguments and names
if ($argv[1] == "--plugin_list" || $noInstall) {
    $filepath = $argv[2];

    if (!$noInstall) {
        // Checking for correct filepaths for csv files
        if (is_dir($filepath)) {
            print_r("Path \"$filepath\" leads to a directory. Please input a path leading to the correct csv file.\n");
            exit();
        }

        if (!file_exists($filepath) || !str_ends_with($filepath, ".csv")) {
            print_r("File \"$filepath\" not found or not a .csv file.\n");
            exit();
        }

        if (file_get_contents($filepath) == null) {
            print_r("No data found in $filepath.\n");
            exit();
        }

        // Installing plugins via wp cli
        foreach (file($filepath) as $line) {
            print_r("----------------------------------------\n");
            [$plugin_slug, $plugin_version] = explode(",", $line);

            if (is_dir("./wp-content/plugins/$plugin_slug/")) {
                print_r("Plugin \"$plugin_slug\" already installed. Skipping installation.\n");
                continue;
            }

            print_r("Installing plugin:\n \"$plugin_slug (v$plugin_version) \" ...\n");
            exec("ddev wp plugin install $plugin_slug --version=$plugin_version");
        }
        print_r("Plugins installed successfully.\n");
        print_r("----------------------------------------\n");
    }
    if (!$noAnalysis) {
        // Check for correct psalm config
        if (!file_exists("./psalm.xml")) {
            print_r("File \"psalm.xml\" not found. Please make sure psalm is setup correctly.\n");
            exit();
        }

        print_r("File \"psalm.xml\" found.\n");
        print_r("Getting installed plugins ...\n");
        $installed_plugins = glob("./wp-content/plugins/*", GLOB_ONLYDIR);
        print_r("Found " . sizeof($installed_plugins) . " plugins.\n");

        $outputs = array();

        // Run psalm taint analysis on each plugin separately
        foreach ($installed_plugins as $plugin_path) {
            // Running psalm for plugin $plugin_path
            print_r("----------------------------------------\n");
            print_r("Running psalm's taint analysis on $plugin_path ...\n");
            change_psalm_project_dir($plugin_path, "./psalm.xml");
            $plugin_slug = explode("/", $plugin_path)[3];
            $output = [];
            exec("./vendor/bin/psalm --taint-analysis", $output);

            $outputs[] = array($plugin_slug => $output);
        }

        $outputHandler = new PsalmAnalysisOutputHandler();
        $analysisResults = $outputHandler->handle(new PsalmOutputParser(), $outputs);


        if (!is_dir("./psalm-result/")) {
            mkdir("./psalm-result/");
        }
        if (!file_exists("./psalm-result/out.json")) {
            fopen("./psalm-result/out.json", "w");
        }
        file_put_contents("./psalm-result/out.json", json_encode($analysisResults, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT));
        print_r("----------------------------------------\n");
        print_r("Analysis results saved to \"./psalm-result/out.json\".\n");
    }
    if ($noAnalysis) {
        $actionsMap = (array)json_decode(file_get_contents("./add-actions-map.json"));
        $functionBodyGetter = new FunctionBodyGetter($actionsMap);
        $files = scanDirForPHPFiles("./wp-content/plugins/");

        foreach ($files as $key => $file) {
            $functionBodyGetter->filterMatchingFunctionBodiesFromFile($file[0]);
        }

        $functionBodyGetter->writeFunctionStmtsToFile("./psalm-result/matched-functions.php");
    } else {
        print_r("Invalid command! Check for usage with --help or -h.\n");
    }
}


function change_psalm_project_dir($plugin_dir_path, $psalm_xml_path): void
{
    $psalm_xml = simplexml_load_file($psalm_xml_path);

    if (!$psalm_xml->projectFiles->directory) {
        print_r("Configuring psalm.xml with correct project directory ...\n");

        $psalm_xml->projectFiles->addChild("directory");
        $psalm_xml->projectFiles->directory->addAttribute("name", $plugin_dir_path);
    }

    if (!$psalm_xml->projectFiles->directory["name"]) {
        print_r("Configuring psalm.xml with correct project directory ...\n");
        $psalm_xml->projectFiles->directory->addAttribute("name", $plugin_dir_path);
    } else {
        print_r("Configuring psalm.xml with correct project directory ...\n");
        $psalm_xml->projectFiles->directory["name"] = $plugin_dir_path;
    }

    $psalm_xml->asXML("./psalm.xml");
    print_r("Configuration of psalm.xml done!\n");
}

function scanDirForPHPFiles(string $directory): array
{
    $directoryIterator = new RecursiveDirectoryIterator($directory);
    $iterator = new RecursiveIteratorIterator($directoryIterator);
    $regex = new RegexIterator($iterator, '/^.+\.php$/i', RecursiveRegexIterator::GET_MATCH);

    return iterator_to_array($regex);
}
